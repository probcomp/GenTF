<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GenTF</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GenTF</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Calling-the-TensorFlow-Python-API-1">Calling the TensorFlow Python API</a></li><li><a class="toctext" href="#TensorFlow-Generative-Functions-1">TensorFlow Generative Functions</a></li><li><a class="toctext" href="#Implementing-parameter-updates-1">Implementing parameter updates</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#API-1">API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/probcomp/GenTF/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="GenTF-1" href="#GenTF-1">GenTF</a></h1><p><em>TensorFlow plugin for the Gen probabilistic programming system</em></p><p>The Julia package <a href="https://github.com/probcomp/GenTF">GenTF</a> allows for <a href="https://github.com/probcomp/Gen">Gen</a> generative functions to invoke TensorFlow computations executed on the GPU by the TensorFlow runtime. Users construct a TensorFlow computation using the familiar TensorFlow Python API, and then package the TensorFlow computation in a <code>TFFunction</code>, which is a type of generative function provided by GenTF. Generative functions written in Gen&#39;s built-in modeling language can seamlessly call <code>TFFunction</code>s. GenTF integrates Gen&#39;s automatic differentiation with TensorFlow&#39;s gradients, allowing automatic differentiation of computations that combine Julia and TensorFlow code.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The installation requires an installation of Python and an installation of the <a href="https://www.tensorflow.org/install/pip">tensorflow</a> Python package. We recommend creating a Python virtual environment and installing TensorFlow via pip in that environment. In what follows, let <code>&lt;python&gt;</code> stand for the absolute path of a Python executable that has access to the <code>tensorflow</code> package.</p><p>From the Julia REPL, type <code>]</code> to enter the Pkg REPL mode and run:</p><pre><code class="language-none">pkg&gt; add https://github.com/probcomp/GenTF</code></pre><p>In a Julia REPL, build the <code>PyCall</code> module so that it will use the correct Python environment:</p><pre><code class="language-julia">using Pkg; ENV[&quot;PYTHON&quot;] = &quot;&lt;python&gt;&quot;; Pkg.build(&quot;PyCall&quot;)</code></pre><p>Check that intended python environment is indeed being used with:</p><pre><code class="language-julia">using PyCall; println(PyCall.python)</code></pre><p>If you encounter problems, see https://github.com/JuliaPy/PyCall.jl#specifying-the-python-version</p><h2><a class="nav-anchor" id="Calling-the-TensorFlow-Python-API-1" href="#Calling-the-TensorFlow-Python-API-1">Calling the TensorFlow Python API</a></h2><p>GenTF uses the Julia package <a href="https://github.com/JuliaPy/PyCall.jl">PyCall</a> to invoke the <a href="https://www.tensorflow.org/api_docs/python/">TensorFlow Python API</a>.</p><p>First, import PyCall:</p><pre><code class="language-julia">using PyCall</code></pre><p>Then import the <code>tensorflow</code> Python module:</p><pre><code class="language-julia">@pyimport tensorflow as tf</code></pre><p>To import a module from a subpackage:</p><pre><code class="language-julia">@pyimport tensorflow.train as train</code></pre><p>Then, call the TensorFlow Python API with syntax that is very close to Python syntax:</p><pre><code class="language-julia">W = tf.get_variable(&quot;W&quot;, dtype=tf.float32, initializer=init_W)
x = tf.placeholder(tf.float32, shape=(3,), name=&quot;x&quot;)
y = tf.squeeze(tf.matmul(W, tf.expand_dims(x, axis=1)), axis=1)
sess = tf.Session()
sess[:run](tf.global_variables_initializer())
y_val = sess[:run](y, feed_dict=Dict(x =&gt; [1., 2., 3.]))</code></pre><p>Here are syntax changes that are required for common situations:</p><ul><li><p>Attributes of Python objects (including methods) are accessed using <code>o[:attr]</code> instead of <code>o.attr</code>. Therefore, to run something in a TensorFlow session <code>sess</code>, use <code>sess[:run](..)</code> instead of <code>sess.run(..)</code>.</p></li><li><p>Where Python dictionaries would be used, use Julia dictionaries instead.</p></li><li><p><code>[1, 1, 1, 1]</code> constructs a Julia <code>Array</code>, which by default gets converted to a numpy array, not a Julia list. When a TensorFlow API function requires that an argument is a Python list or a tuple (e.g. the <code>strides</code> argument of <a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d">tf.nn.conv2d</a>), use a Julia tuple: <code>(1, 1, 1, 1)</code>.</p></li></ul><p>See the <a href="https://github.com/JuliaPy/PyCall.jl">PyCall README</a> for the complete description of syntax differences introduced when using Julia and PyCall instead of Python.</p><h2><a class="nav-anchor" id="TensorFlow-Generative-Functions-1" href="#TensorFlow-Generative-Functions-1">TensorFlow Generative Functions</a></h2><p>A TensorFlow computation graph contains both the model(s) being trained as well as the operations that do the training. In contrast, Gen uses a more rigid separation between models (both generative models and inference models) and the operations that act on models. Specifically, models in Gen are defined as (pure functional) <em>generative functions</em>, and the operations that run the models or train the models are defined in separate Julia code. The GenTF package allows users to construct deterministic generative functions of type <code>TFFunction &lt;: GenerativeFunction</code> from a TensorFlow computation graph in which each TensorFlow element is one of the following roles:</p><table><tr><th>Role in <code>TFFunction</code></th><th>TensorFlow object type</th></tr><tr><td>Argument</td><td>tf.Tensor produced by tf.placeholder</td></tr><tr><td>Trainable Parameter</td><td>tf.Variable</td></tr><tr><td>Operation in Body</td><td>tf.Tensor produced by non-mutating TensorFlow operation (e.g. tf.conv2d)</td></tr><tr><td>N/A</td><td>tf.Tensor produced by mutating TensorFlow operation (e.g. tf.assign)</td></tr></table><p>TensorFlow placeholders play the role of <strong>arguments</strong> to the generative function. TensorFlow Variables play the role of the <strong>trainable parameters</strong> of the generative function. Their value is shared across all invocations of the generative function and is managed by the TensorFlow runtime, not Julia. We will discuss how to train these parameters in section <a href="#Implementing-parameter-updates-1">Implementing parameter updates</a>. Tensors produced from non-mutating operations comprise the <strong>body</strong> of the generative function. One of these elements (either an argument parameter, or element of the body) is designated the <strong>return value</strong> of the generative function. Note that we do not currently permit TensorFlow generative functions to use randomness.</p><p>To construct a TensorFlow generative function, we first construct the TensorFlow computation graph using the TensorFlow Python API:</p><pre><code class="language-julia">using Gen
using GenTF
using PyCall

@pyimport tensorflow as tf
@pyimport tensorflow.nn as nn

xs = tf.placeholder(tf.float64) # N x 784
W = tf.Variable(zeros(Float64, 784, 10))
b = tf.Variable(zeros(Float64, 10))
probs = nn.softmax(tf.add(tf.matmul(xs, W), b), axis=1) # N x 10</code></pre><p>Then we construct a <code>TFFunction</code> from the TensorFlow graph objects. The first argument to <code>TFFunction</code> is the TensorFlow session, followed by a <code>Vector</code> of trainable parameters (<code>W</code> and <code>b</code>), a <code>Vector</code> of arguments (<code>xs</code>), and finally the <strong>return value</strong> (<code>probs</code>).</p><pre><code class="language-none">sess = tf.Session()
tf_func = TFFunction([W, b], [xs], probs, sess)</code></pre><p>The return value must be a differentiable function of each argument and each parameter. Note that the return value does <em>not</em> need to be a scalar. TensorFlow computations for gradients with respect to the arguments and with respect to the parameters are automatically generated when constructing the <code>TFFunction</code>.</p><p>If a session is not provided a new session is created:</p><pre><code class="language-julia">tf_func = TFFunction([W, b], [xs], probs)</code></pre><p>Values for the parameters are managed by the TensorFlow runtime. The TensorFlow session that contains the parameter values is obtained with:</p><pre><code class="language-julia">sess = get_session(tf_func)</code></pre><p>The value of a trainable parameter can be obtained in Julia by fetching the Python Variable object (e.g. &#39;W&#39;):</p><pre><code class="language-julia">W_value = sess[:run](W)</code></pre><p>Equivalently, this can be done using a more concise syntax with the <code>runtf</code> method:</p><pre><code class="language-julia">W_value = runtf(tf_func, W)</code></pre><h3><a class="nav-anchor" id="What-happens-during-[Gen.generate](https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.generate)-1" href="#What-happens-during-[Gen.generate](https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.generate)-1">What happens during <a href="https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.generate"><code>Gen.generate</code></a></a></h3><p>Suppose we run <code>generate</code> on the <code>TFFunction</code>:</p><pre><code class="language-julia">(trace, weight) = generate(tf_func, (xs_val,), choicemap())</code></pre><ul><li><p>The TensorFlow runtime computes the return value for the given values of the arguments and the current values of of the trainable parameters.</p></li><li><p>The return value is obtained by Julia from TensorFlow and stored in the trace (it is accessible with <code>get_retval(trace)</code>).</p></li><li><p>The given argument values are also stored in the trace (accessible with <code>get_args(trace)</code>).</p></li></ul><p>Note that we pass an empty assignment to <code>generate</code> because a <code>TFFunction</code> cannot make any random choices that could be constrained.</p><h3><a class="nav-anchor" id="What-happens-during-[Gen.choice_gradients](https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.choice_gradients)-1" href="#What-happens-during-[Gen.choice_gradients](https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.choice_gradients)-1">What happens during <a href="https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.choice_gradients"><code>Gen.choice_gradients</code></a></a></h3><p>When running <code>choice_gradients</code> with a trace produced from a <code>TFFunction</code>, we must pass a gradient value for the return value. This value should be a Julia <code>Array</code> with the same shape as the return value.</p><pre><code class="language-julia">((xs_grad,), _, _) = choice_gradients(trace, select(), retval_grad)</code></pre><ul><li><p>The gradients with respect to each argument are computed by the TensorFlow runtime.</p></li><li><p>The values of the gradient are converted to Julia values and returned.</p></li></ul><p>Note that we pass an empty selection because a <code>TFFunction</code> does not make any random choices that could be selected.</p><h3><a class="nav-anchor" id="What-happens-during-[Gen.accumulate_param_gradients!](https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.accumulate_param_gradients!)-1" href="#What-happens-during-[Gen.accumulate_param_gradients!](https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.accumulate_param_gradients!)-1">What happens during <a href="https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.accumulate_param_gradients!"><code>Gen.accumulate_param_gradients!</code></a></a></h3><p>When running <code>accumulate_param_gradients!</code> with a trace produced from a <code>TFFunction</code>, we must pass a gradient value for the return value. This value should be a Julia <code>Array</code> with the same shape as the return value.</p><pre><code class="language-julia">(xs_grad,) = accumulate_param_gradients!(trace, retval_grad)</code></pre><ul><li><p>Like <code>choice_gradients</code>, the method returns the value of the gradient with respect to the arguments</p></li><li><p>The gradient with respect to each trainable parameters is computed by the TensorFlow runtime.</p></li><li><p>A <strong>gradient accumulator</strong> TensorFlow Variable for each trainable parameter is incremented by the corresponding gradient value.</p></li></ul><p>The gradient accumulator for a parameter accumulates gradient contributions over multiple invocations of <code>accumulate_param_gradients!</code>. A gradient accumulator TensorFlow Variable value can be obtained from the <code>TFFunction</code> with <code>get_param_grad_tf_var</code> (see <a href="#API-1">API</a> below). The value of all gradient accumulators for a given <code>TFFunction</code> can be reset to zeros with <code>reset_param_grads_tf_op</code> (see <a href="#API-1">API</a> below).</p><h2><a class="nav-anchor" id="Implementing-parameter-updates-1" href="#Implementing-parameter-updates-1">Implementing parameter updates</a></h2><p>Updates to the trainable parameters of a <code>TFFunction</code> are also defined using the TensorFlow Python API. For example, below we define a TensorFlow operation to apply one step of stochastic gradient descent, based on the current values of the gradient accumulators for all parameters:</p><pre><code class="language-julia">opt = train.GradientDescentOptimizer(.00001)
grads_and_vars = []
push!(grads_and_vars, (tf.negative(get_param_grad_tf_var(tf_func, W)), W))
push!(grads_and_vars, (tf.negative(get_param_grad_tf_var(tf_func, b)), b))
update = opt[:apply_gradients](grads_and_vars)</code></pre><p>We can then apply this update with:</p><pre><code class="language-julia">sess[:run](update)</code></pre><p>We can reset the gradient accumulators to zero when desired with:</p><pre><code class="language-julia">sess[:run](reset_param_grads_tf_op(tf_func))</code></pre><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>See the <code>examples/</code> directory for examples that show <code>TFFunction</code>s being combined with regular Gen functions.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GenTF.TFFunction" href="#GenTF.TFFunction"><code>GenTF.TFFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">gen_fn = TFFunction(params::Vector{PyObject},
                    inputs::Vector{PyObject}, output::PyObject,
                    sess::PyObject=tf.compat.v1.Session())</code></pre><p>Construct a TensorFlow generative function from elements of a TensorFlow computation graph.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/GenTF/blob/4637b43f4cf520684234bb561a23808a32d3f20d/src/GenTF.jl#L49-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GenTF.get_session" href="#GenTF.get_session"><code>GenTF.get_session</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_session(gen_fn::TFFunction)</code></pre><p>Return the TensorFlow session associated with the given function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/GenTF/blob/4637b43f4cf520684234bb561a23808a32d3f20d/src/GenTF.jl#L116-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GenTF.runtf" href="#GenTF.runtf"><code>GenTF.runtf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">runtf(gen_fn::TFFunction, ...)</code></pre><p>Fetch values or run operations in the TensorFlow session associated with the given function.</p><p>Syntactic sugar for <code>get_session(gen_fn).run(args...)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/GenTF/blob/4637b43f4cf520684234bb561a23808a32d3f20d/src/GenTF.jl#L123-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GenTF.get_param_grad_tf_var" href="#GenTF.get_param_grad_tf_var"><code>GenTF.get_param_grad_tf_var</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">var::PyObject = get_param_grad_tf_var(gen_fn::TFFunction, param::PyObject)</code></pre><p>Return the TensorFlow Variable that stores the gradient of the given parameter TensorFlow Variable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/GenTF/blob/4637b43f4cf520684234bb561a23808a32d3f20d/src/GenTF.jl#L108-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GenTF.reset_param_grads_tf_op" href="#GenTF.reset_param_grads_tf_op"><code>GenTF.reset_param_grads_tf_op</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">op::PyObject = reset_param_grads_tf_op(gen_fn::TFFunction)</code></pre><p>Return the TensorFlow operation Tensor that resets the gradients of all parameters of the given function to zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/GenTF/blob/4637b43f4cf520684234bb561a23808a32d3f20d/src/GenTF.jl#L98-L101">source</a></section><footer><hr/></footer></article></body></html>
